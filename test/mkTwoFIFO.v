//
// Generated by Bluespec Compiler, version 2022.01 (build 066c7a8)
//
// On Sat Nov 12 19:25:38 PST 2022
//
//
// Ports:
// Name                         I/O  size props
// RDY_enq                        O     1
// RDY_deq                        O     1
// first                          O     8
// RDY_first                      O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// enq_x                          I     8 reg
// EN_enq                         I     1
// EN_deq                         I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTwoFIFO(CLK,
		 RST_N,

		 enq_x,
		 EN_enq,
		 RDY_enq,

		 EN_deq,
		 RDY_deq,

		 first,
		 RDY_first);
  input  CLK;
  input  RST_N;

  // action method enq
  input  [7 : 0] enq_x;
  input  EN_enq;
  output RDY_enq;

  // action method deq
  input  EN_deq;
  output RDY_deq;

  // value method first
  output [7 : 0] first;
  output RDY_first;

  // signals for module outputs
  wire [7 : 0] first;
  wire RDY_deq, RDY_enq, RDY_first;

  // ports of submodule fifo1
  wire [7 : 0] fifo1$D_IN, fifo1$D_OUT;
  wire fifo1$CLR, fifo1$DEQ, fifo1$EMPTY_N, fifo1$ENQ, fifo1$FULL_N;

  // ports of submodule fifo2
  wire [7 : 0] fifo2$D_IN, fifo2$D_OUT;
  wire fifo2$CLR, fifo2$DEQ, fifo2$EMPTY_N, fifo2$ENQ, fifo2$FULL_N;

  // action method enq
  assign RDY_enq = fifo1$FULL_N && fifo2$FULL_N ;

  // action method deq
  assign RDY_deq = fifo1$EMPTY_N && fifo2$EMPTY_N ;

  // value method first
  assign first = fifo1$D_OUT ^ fifo2$D_OUT ;
  assign RDY_first = fifo1$EMPTY_N && fifo2$EMPTY_N ;

  // submodule fifo1
  FIFO2 #(.width(32'd8), .guarded(1'd1)) fifo1(.RST(RST_N),
					       .CLK(CLK),
					       .D_IN(fifo1$D_IN),
					       .ENQ(fifo1$ENQ),
					       .DEQ(fifo1$DEQ),
					       .CLR(fifo1$CLR),
					       .D_OUT(fifo1$D_OUT),
					       .FULL_N(fifo1$FULL_N),
					       .EMPTY_N(fifo1$EMPTY_N));

  // submodule fifo2
  FIFO2 #(.width(32'd8), .guarded(1'd1)) fifo2(.RST(RST_N),
					       .CLK(CLK),
					       .D_IN(fifo2$D_IN),
					       .ENQ(fifo2$ENQ),
					       .DEQ(fifo2$DEQ),
					       .CLR(fifo2$CLR),
					       .D_OUT(fifo2$D_OUT),
					       .FULL_N(fifo2$FULL_N),
					       .EMPTY_N(fifo2$EMPTY_N));

  // submodule fifo1
  assign fifo1$D_IN = enq_x ;
  assign fifo1$ENQ = EN_enq ;
  assign fifo1$DEQ = EN_deq ;
  assign fifo1$CLR = 1'b0 ;

  // submodule fifo2
  assign fifo2$D_IN = enq_x ;
  assign fifo2$ENQ = EN_enq ;
  assign fifo2$DEQ = EN_deq ;
  assign fifo2$CLR = 1'b0 ;
endmodule  // mkTwoFIFO

